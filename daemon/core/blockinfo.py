from block import BlockInfo, GateInfo, VariableInfo, IntegerRange

block_infos = {"FlowMeter": BlockInfo("FlowMeter", "indirect", [GateInfo("output", "out_flow", "Flow", IntegerRange(0, 0)), GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       attribute store_packets {xsd:boolean}?\n       element idle_timeout{\n            attribute ms {xsd:integer}\n            }?\n       element idle_timeout{\n            attribute ms {xsd:integer}\n            }?\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params store_packets='true'>\n           <active_timeout ms='500'/>\n           <idle_timeout ms='100'/>\n      </params>\n    </paramsexample>\n", [], "Receives packet messages and keeps a table of per-flow statistics, and, depending on the configuration, also the packets making up that flow.        A circular queue is used to keep track of the last time a flow has been checked for         expiration.         Two timeout values are used. The first one is the idle timeout (default value is 500 ms): whenever a flow record has not been        receiving a packet for more than such time interval, the flow is considered as expired, its associated        record is sent out and its table entry erased .      The second one, the active timeout (default value is 100 ms), is activated when a flow has been active for longer than the corresponding time        interval. When such timeout expires, a record about the flow is sent out and the counters in the corresponding table entry        are reset.         Notice that, while the idle timeout is checked by using a Blockmon timer mechanism, the indirect timeout is checked upon        arrival of a new packet belonging to the flow.", "Receives packet messages and keeps a table of per-flow statistics, and, depending on the configuration, also the packets making up that flow.", False), "CDFGenerator": BlockInfo("CDFGenerator", "both", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element cdf_build {\n                attribute interval {xsd:integer}\n            }\n       element cdf_param{\n            attribute min {xsd:integer}\n            attribute max {xsd:integer}\n            attribute bin {xsd:integer}\n            }\n       element diff_priv{\n            attribute epsilon {xsd:float}\n            }\n        }\n     }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n             <build_cdf interval='2000'/> #millisecond\n             <cdf_param min='0' max='1500' bin='150'/>\n             <diff_priv epsilon='0.8'/> #if -1 do not add noise\n        </params>\n    </paramsexample>\n", [], "Implements a block that prints the Cumulative Distribution Function        (CDF) of the packet size every interval, adding a noise depending on        the epsilon value. Configuration parameters allow to tune the        endpoints of the CDF, the bin width and to add noise.", "Prints the CDF of packet sizes for a given interval", False), "IPFIXSource": BlockInfo("IPFIXSource", "async", [GateInfo("output", "source_out", "Any", IntegerRange(0, 0))], "   <paramsschema>\n     element params {\n        element collect {\n            attribute transport {'udp'|'tcp'|'sctp'},\n            attribute port      {xsd:integer}?\n            } |\n        element file {\n            attribute name {text}\n        }\n        element datatype {\n            attribute name {text}\n        }\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <collect port='4739' transport='tcp'/>\n        <datatype name='ipv4flow'/>\n        or\n        <file name='foo.ipfix'/>\n        <datatype name='ipv4flow'/>\n      </params>\n    </paramsexample>\n", [], "Reads records from an IPFIX transport session and outputs messages       according to the datatypes registered with the source block. May      send out Messages of any type, depending on the data received from       the remote IPFIX device and the the registered data types.", "Receives messages from an IPFIX exporter", True), "PacketPrinter": BlockInfo("PacketPrinter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Receives a Packet message and prints its associated information    (as returned by the methods in the Packet class)", "Prints meta-information regarding a packet", False), "L4Demux": BlockInfo("L4Demux", "direct", [GateInfo("input", "in_pkt", "Msg", IntegerRange(0, 0)), GateInfo("output", "out_tcp", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_udp", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_unknown", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n    </paramsexample>\n", [], "Takes Packet messages and demultiplexes them across three possible output    gates depending on their transport protocol: TCP packets are forwarded    through the out_tcp gate, UDP packets through out_udp and any other packet    through out_unknown.", "Demultiplexes packets based on their transport protocol", False), "PacketCounter": BlockInfo("PacketCounter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element notimer {text}?\n       }\n \n    </paramsschema>\n", "     <paramsexample>\n         <params>\n               <notimer/>\n           </params>\n        \n    </paramsexample>\n", [VariableInfo("PacketCounter", "pktcnt", "integer", "read"), VariableInfo("PacketCounter", "bytecnt", "integer", "read"), VariableInfo("PacketCounter", "byterate", "integer", "read"), VariableInfo("PacketCounter", "pktrate", "integer", "read"), VariableInfo("PacketCounter", "reset", "write 1 to reset packet and byte counts", "write")], "Keeps packet and byte counts of traffic going through it and logs,      every 0.5 seconds, the packet rate.      An xml parameter can be used in order to disable the timer mechanism.", "Keeps packet and byte counts of traffic going through it.", False), "PacketFilter": BlockInfo("PacketFilter", "direct", [GateInfo("input", "in_pkt", "Msg", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n           element l3_protocol{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element ip_src{\n            attribute address {text}\n            attribute netmask {text}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element ip_dst{\n            attribute address {text}\n            attribute netmask {text}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element l4_protocol{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element src_port{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element dst_port{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           }\n     }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n            <l3_protocol number='2048'>\n                <filter_mode behavior='accept'/>\n            </l3_protocol>\n \n            <ip_src address='131.114.54.0' netmask='255.255.252.0'>\n                <filter_mode behavior='discard'/>\n            </ip_src>\n \n            <ip_dst address='131.114.54.0' netmask='255.255.252.0'>\n                <filter_mode behavior='accept'/>\n             </ip_dst>\n \n             <l4_protocol number='6'>\n                <filter_mode behavior='accept'/>\n            </l4_protocol>\n \n            <src_port number='80'>\n                <filter_mode behavior='accept'/>\n            </src_port>\n \n      </params>\n    </paramsexample>\n", [], "", "Selects packets based on conditions specified over the 5-tuple", False), "FlowCounter": BlockInfo("FlowCounter", "direct", [GateInfo("input", "in_pkt", "Flow", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element notimer {text}?\n       }\n \n    </paramsschema>\n", "     <paramsexample>\n         <params>\n               <notimer/>\n           </params>\n        \n    </paramsexample>\n", [VariableInfo("FlowCounter", "pktcnt", "integer", "read"), VariableInfo("FlowCounter", "bytecnt", "integer", "read"), VariableInfo("FlowCounter", "flowcnt", "integer", "read"), VariableInfo("FlowCounter", "byterate", "integer", "read"), VariableInfo("FlowCounter", "pktrate", "integer", "read"), VariableInfo("FlowCounter", "flowrate", "integer", "read"), VariableInfo("FlowCounter", "reset", "write 1 to reset counts", "write")], "Keeps flow, packet and byte counts of Flows going through it.      An xml parameter can be used in order to disable the timer mechanism.", "Keeps flow packet and byte counts of traffic going through it.", False), "SynFloodAlertManager": BlockInfo("SynFloodAlertManager", "direct", [GateInfo("input", "in_alert", "Alert", IntegerRange(0, 0)), GateInfo("output", "out_alert", "Alert", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n  		element history {\n 		  attribute size {integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <history size='1000' />\n      </params>\n    </paramsexample>\n", [], "Receives different alerts from TCPFlagCounter blocks and merges them into more 	   informative alerts, ready for mitigation.      Keeps an history of the alerts with a configurable maximum size.", "Receives SYN flooding alerts and summarizes them.", False), "ComboUHSource": BlockInfo("ComboUHSource", "indirect", [GateInfo("output", "out_pkt", "UHPacket", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element design {\n           attribute filename {xsd:string}\n       }\n       element channels {\n           attribute rx_mask {xsd:integer}\n       }\n       element interfaces {\n           attribute enable {xsd:integer}\n       }\n       element device {\n           attribute device {xsd:integer}\n       }\n       element filter {\n           attribute filename {xsd:string}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n   <params>\n       <design filename='/path/to/firmware.mcs'/>\n       <channels rx_mask='255'/>\n       <interfaces enable='1'/>\n       <device number='0' />\n       <filter filename='/path/to/filter.xml' />\n   </params>\n    </paramsexample>\n", [VariableInfo("ComboUHSource", "pktagg_read", "integer", "read"), VariableInfo("ComboUHSource", "pktagg_write", "integer", "write"), VariableInfo("ComboUHSource", "pktcnt", "integer", "read"), VariableInfo("ComboUHSource", "pktcnt_reset", "integer", "write"), VariableInfo("ComboUHSource", "IBUF0_TRFC", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_CFC", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_DFC", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_BODFC", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_EN", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_ERRMASK", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_STATUS", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_CTRL", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_FML", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_MTU", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_MACCHK", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_BUFSIZE", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_MEMMAC", "integer", "read"), VariableInfo("ComboUHSource", "IBUF0_RESET", "write 1 to reset counters", "write"), VariableInfo("ComboUHSource", "IBUF1_TRFC", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_CFC", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_DFC", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_BODFC", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_EN", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_ERRMASK", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_STATUS", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_CTRL", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_FML", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_MTU", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_MACCHK", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_BUFSIZE", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_MEMMAC", "integer", "read"), VariableInfo("ComboUHSource", "IBUF1_RESET", "write 1 to reset counters", "write"), VariableInfo("ComboUHSource", "OBUF0_CNT_PACKETS", "integer", "read"), VariableInfo("ComboUHSource", "OBUF0_CNT_RECV", "integer", "read"), VariableInfo("ComboUHSource", "OBUF0_CNT_RECVERR", "integer", "read"), VariableInfo("ComboUHSource", "OBUF0_EN", "integer", "read"), VariableInfo("ComboUHSource", "OBUF0_MAC", "integer", "read"), VariableInfo("ComboUHSource", "OBUF0_CTRL", "integer", "read"), VariableInfo("ComboUHSource", "OBUF0_STATUS", "integer", "read"), VariableInfo("ComboUHSource", "OBUF0_RESET", "write 1 to reset counters", "write"), VariableInfo("ComboUHSource", "OBUF1_CNT_PACKETS", "integer", "read"), VariableInfo("ComboUHSource", "OBUF1_CNT_RECV", "integer", "read"), VariableInfo("ComboUHSource", "OBUF1_CNT_RECVERR", "integer", "read"), VariableInfo("ComboUHSource", "OBUF1_EN", "integer", "read"), VariableInfo("ComboUHSource", "OBUF1_MAC", "integer", "read"), VariableInfo("ComboUHSource", "OBUF1_CTRL", "integer", "read"), VariableInfo("ComboUHSource", "OBUF1_STATUS", "integer", "read"), VariableInfo("ComboUHSource", "OBUF1_RESET", "write 1 to reset counters", "write")], "This block is a wrapper to the SZE2 API available as a part of NetCOPE FPGA framework:     http://www.invea-tech.com/products-and-services/netcope-fpga-platform     A block of this kind can be associated to one or more hardware queues    available on the FPGA acceleration card. Subscribed queues are specified    as a configuration parameter in a mask where each bit corresponds to a single queue.    If no value is provided default value is used. This block supports batch    message allocation in order to optimize performance", "Captures traffic from a local interface by means of the SZE2 API as part of NetCOPE", True), "PacketCounter": BlockInfo("PacketCounter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element notimer {text}?\n       }\n \n    </paramsschema>\n", "     <paramsexample>\n         <params>\n               <notimer/>\n           </params>\n        \n    </paramsexample>\n", [VariableInfo("PacketCounter", "pktcnt", "integer", "read"), VariableInfo("PacketCounter", "bytecnt", "integer", "read"), VariableInfo("PacketCounter", "byterate", "integer", "read"), VariableInfo("PacketCounter", "pktrate", "integer", "read"), VariableInfo("PacketCounter", "reset", "write 1 to reset packet and byte counts", "write")], "Keeps packet and byte counts of traffic going through it and logs,      every 0.5 seconds, the packet rate.      An xml parameter can be used in order to disable the timer mechanism.", "Keeps packet and byte counts of traffic going through it.", False), "RRDemux": BlockInfo("RRDemux", "direct", [GateInfo("input", "input", "Msg", IntegerRange(0, 0)), GateInfo("output", "output1", "Msg", IntegerRange(0, 0)), GateInfo("output", "output2", "Msg", IntegerRange(0, 0)), GateInfo("output", "outputN", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element gates {\n         attribute number {integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <gates number='5' />\n      </params>\n    </paramsexample>\n", [], "Receives messages and sends them through a configured number      of output gates in a round-robin fashion. There can be any number of      output gates, each named outputX with X going from 1 to the configured      number of gates.", "Sends messages out through its gates in a round-robin fashion", False), "SynthSource": BlockInfo("SynthSource", "indirect", [GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element rate {\n         attribute pps {xsd:integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <rate pps='10000'/>\n      </params>\n    </paramsexample>\n", [], "Generates TCP/IP packets with random IP addresses and ports.    The number of packets per second can be tuned as a configuration parameter.", "Generates synthetic traffic with random addresses and ports", True), "IPDumbAnonymizer": BlockInfo("IPDumbAnonymizer", "both", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element anon {\n         attribute src {'True' | 'False'}?\n         attribute dst {'True' | 'False'}?\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <anon src='True'/>\n      </params>\n    </paramsexample>\n", [], "This block can anonymize the source address and/or the destination    address of an IP packet (this can be set as config param). Notice that, as    this operation needs to modify the packet contents, the message is cloned    before being modified.", "Anonymizes ip addresses in a Packet message", False), "Null": BlockInfo("Null", "direct", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Discards every message it receives.", "Discards every message it receives.", False), "ComboPktSource": BlockInfo("ComboPktSource", "indirect", [GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element design {\n           attribute filename {xsd:string}\n       }\n       element channels {\n           attribute rx_mask {xsd:integer}\n       }\n       element interfaces {\n           attribute enable {xsd:integer}\n       }\n       element device {\n           attribute device {xsd:integer}\n       }\n       element filter {\n           attribute filename {xsd:string}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n   <params>\n       <design filename='/path/to/firmware.mcs'/>\n       <channels rx_mask='255'/>\n       <interfaces enable='1'/>\n       <device number='0' />\n       <filter filename='/path/to/filter.xml' />\n   </params>\n    </paramsexample>\n", [VariableInfo("ComboPktSource", "pktagg_read", "integer", "read"), VariableInfo("ComboPktSource", "pktagg_write", "integer", "write"), VariableInfo("ComboPktSource", "pktcnt", "integer", "read"), VariableInfo("ComboPktSource", "pktcnt_reset", "integer", "write"), VariableInfo("ComboPktSource", "IBUF0_TRFC", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_CFC", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_DFC", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_BODFC", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_EN", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_ERRMASK", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_STATUS", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_CTRL", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_FML", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_MTU", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_MACCHK", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_BUFSIZE", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_MEMMAC", "integer", "read"), VariableInfo("ComboPktSource", "IBUF0_RESET", "write 1 to reset counters", "write"), VariableInfo("ComboPktSource", "IBUF1_TRFC", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_CFC", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_DFC", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_BODFC", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_EN", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_ERRMASK", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_STATUS", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_CTRL", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_FML", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_MTU", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_MACCHK", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_BUFSIZE", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_MEMMAC", "integer", "read"), VariableInfo("ComboPktSource", "IBUF1_RESET", "write 1 to reset counters", "write"), VariableInfo("ComboPktSource", "OBUF0_CNT_PACKETS", "integer", "read"), VariableInfo("ComboPktSource", "OBUF0_CNT_RECV", "integer", "read"), VariableInfo("ComboPktSource", "OBUF0_CNT_RECVERR", "integer", "read"), VariableInfo("ComboPktSource", "OBUF0_EN", "integer", "read"), VariableInfo("ComboPktSource", "OBUF0_MAC", "integer", "read"), VariableInfo("ComboPktSource", "OBUF0_CTRL", "integer", "read"), VariableInfo("ComboPktSource", "OBUF0_STATUS", "integer", "read"), VariableInfo("ComboPktSource", "OBUF0_RESET", "write 1 to reset counters", "write"), VariableInfo("ComboPktSource", "OBUF1_CNT_PACKETS", "integer", "read"), VariableInfo("ComboPktSource", "OBUF1_CNT_RECV", "integer", "read"), VariableInfo("ComboPktSource", "OBUF1_CNT_RECVERR", "integer", "read"), VariableInfo("ComboPktSource", "OBUF1_EN", "integer", "read"), VariableInfo("ComboPktSource", "OBUF1_MAC", "integer", "read"), VariableInfo("ComboPktSource", "OBUF1_CTRL", "integer", "read"), VariableInfo("ComboPktSource", "OBUF1_STATUS", "integer", "read"), VariableInfo("ComboPktSource", "OBUF1_RESET", "write 1 to reset counters", "write")], "This block is a wrapper to the SZE2 API available as a part of NetCOPE FPGA framework:     http://www.invea-tech.com/products-and-services/netcope-fpga-platform     A block of this kind can be associated to one or more hardware queues    available on the FPGA acceleration card. Subscribed queues are specified    as a configuration parameter in a mask where each bit corresponds to a single queue.    If no value is provided default value is used. This block supports batch    message allocation in order to optimize performance", "Captures traffic from a local interface by means of the SZE2 API as part of NetCOPE", True), "AppendTag": BlockInfo("AppendTag", "both", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element tag\n        {\n            attribute type {'long'|'double'|'int'}\n            attribute id {text}\n        }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <tag type='double' name = 'random_tag'/>\n      </params>\n    </paramsexample>\n", [], "This is a test-only block that appends random-value tags to Packet messages.        The block can append three different tag type, which can be configured at block configuration time.        The content of the tag to be written is a 64-bit random value which is computed on a per-packet base.", "Appends tags with random values to the packet message.", False), "PcapSource": BlockInfo("PcapSource", "async", [GateInfo("output", "source_out", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element source {\n         attribute type {'live' | 'trace'}\n         attribute name {text}\n       }\n       element bpf_filter {text}?\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <source type='live' name='eth0'>\n         or\n         <source type='trace' name='trace.pcap'>\n \n       <bpf_filter expression=' '>\n      </params>\n    </paramsexample>\n", [], "Captures traffic from a local interface or pcap trace file and outputs      packets using a Packet message. If the source parameter is set to live,      the name parameter should be an interface's name (e.g., eth0). If the      source type is set to trace, then the name should be the full path to a      pcap trace file (e.g., /tmp/mytrace.pcap). Use the bfp paramter to filter      traffic using BFP syntax.", "Captures traffic from a local interface or pcap trace file", True), "PFQSource": BlockInfo("PFQSource", "indirect", [GateInfo("output", "source_out", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element queues {\n           attribute device {text}\n           element queue {\n                attribute number {xsd:integer}\n                }\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n   <params>                                                                                                                                 \n       <queues device='eth3'>\n           <queue number='0'/>\n       </queues> \n   </params>\n    </paramsexample>\n", [], "Wrapper to the PFQ capturing engine:     http://netgroup.iet.unipi.it/software/pfq/     A block of this kind can be associated to a network interface or to a    subset of its associated hardware queues. This is specified as a    configuration parameter: a set of queues for the interface can be    specified, if this is empty the block captures all of the packets on the interface.    This block supports batch message allocation in order to optimize performance", "Captures traffic from a local interface by means of the PFQ capturing engine", True), "PeriodFlowMeter": BlockInfo("PeriodFlowMeter", "indirect", [GateInfo("output", "out_flow", "Flow", IntegerRange(0, 0)), GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element timeout{\n            attribute ms {xsd:integer}\n            }?\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n           <timeout ms='500'/>\n      </params>\n    </paramsexample>\n", [], "Receives packet messages and keeps a table of per-flow statistics.        Upon expiration of a timer (default is 500 ms), the whole table is flushed: a Flow message for        every table entry is sent out and the whole state of the table is erased.", "Receives packet messages and keeps a table of per-flow    statistics, exporting them periodically", False), "TopNFlowSelector": BlockInfo("TopNFlowSelector", "both", [GateInfo("output", "out_flow", "Flow", IntegerRange(0, 0)), GateInfo("input", "in_flow", "Flow", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element top_flows{\n        attribute number {xsd:integer}\n        }?\n        element period{\n        attribute msecs {xsd:integer}\n        }?\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n             <top_flows number='10'/>\n             <period msecs='4000'/>\n      </params>\n    </paramsexample>\n", [], "Receives Flow messages and keeps a list of the N messages with the highest number of packets         Upon expiration of a timer, it sends all of them out of its out gate.         The number N of messages to be selected, along with the flush period, are optional configuration parameters.         Default values are 10 messages and 100ms respectively", "Selects the flows with the highest number of packets", False), "IDMEFSource": BlockInfo("IDMEFSource", "async", [GateInfo("output", "source_out", "Alert", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element collect {\n            attribute port {xsd:integer}\n            } |\n        element file {\n            attribute name {text}\n        }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <collect port='1234' />\n      </params>\n    </paramsexample>\n", [], "Creates and sends alert messages from a source respecting the IDMEF format.      The source can be a file or a distant machine through TCP. 	   Using TCP, the source acts as a server that can receive from only 1 client.      Only a very small subset of IDMEF is supported. For now this block is only      meant to be used with the IDMEFSource block.", "Listens to an IDMEF source and sends alert messages", False), "FlowPrinter": BlockInfo("FlowPrinter", "direct", [GateInfo("input", "in_flow", "Flow", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Receives a Flow message and prints its associated information (as returned    by the methods in the Flow class)", "Prints meta-information regarding a flow", False), "IDMEFExporter": BlockInfo("IDMEFExporter", "direct", [GateInfo("input", "in_alert", "Alert", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element export {\n            attribute host  {text},\n            attribute port {xsd:integer}\n            } |\n        element file {\n            attribute name {text}\n        }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <export host='192.168.0.3' port='1234' />\n      </params>\n    </paramsexample>\n", [], "Receives alert messages and exports them as IDMEF.      Export can ben done to a file or to a distant machine through TCP.", "Receives alert messages and exports them as IDMEF", False), "SketchMerger": BlockInfo("SketchMerger", "direct", [GateInfo("input", "in_sketch", "SketchMsg", IntegerRange(0, 0)), GateInfo("output", "out_sketch", "SketchMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element merge {\n         attribute number {integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <merge number='3' />\n      </params>\n    </paramsexample>\n", [], "Receives CMS sketches and merges them to send only one.  	   All sketches received should have the same width and depth, and use the      same hash functions. When the configured number of sketches have been received,  	   they are merged together and sent, and the cycle restarts.", "Receives CMS sketches and merges them.", False), "SketchFlowCounter": BlockInfo("SketchFlowCounter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n     }\n    </paramsschema>\n", "    <paramsexample>\n    </paramsexample>\n", [], "Counts the number of packets per flow using a sketch, where a flow is      identified using the 5-tuple. Only TCP and UDP packets are considered.", "Counts the number of packets per flow using a sketch", False), "TCPFlagCounter": BlockInfo("TCPFlagCounter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0)), GateInfo("input", "in_alert", "Alert", IntegerRange(0, 0)), GateInfo("output", "out_alert", "Alert", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element export {\n         attribute period {integer}\n       }\n       element sketch {\n         attribute width {integer}\n         attribute depth {integer}\n         element hash {\n           attribute a {integer}\n           attribute b {integer}\n         }\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n       <params>\n       <export period='500000' />\n       <sketch width='1024' depth='2'>\n         <hash a='12' b='4587' />\n         <hash a='458' b='56332' />\n       </sketch>\n      </params>\n    </paramsexample>\n", [], "Counts the TCP SYN packets sent to each IP. Stores the counts  	   in a CMS sketch and sends the sketch regularly.  	   In a future version, the TCP flags counted will be configureable.   	   Packets are received through the gate in_pkt.  	   The CMS sketch can be configured:  	    width is the number of values each hash function can take  	    depth is the number of hash functions       hash functions may be defined by their parameters a and b. If there        are not at least 'depth' functions defined, they will be chosen 		 randomly.  	   The export rate can be configured:  	    period is the number of microseconds between each sketch is sent.  	   Alerts can also be received through gate in_alert. These      alerts contain the indexes of counts in alarm. This blocks associates      them with a destination IP that it logs when an alert is received.      The destination IP is determined using a list of recently-seen IPs and sent      as an enriched alert.", "Counts TCP SYN packets by target IP in sketches", False), "FlowFilter": BlockInfo("FlowFilter", "direct", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n            element ip_src{\n            attribute address {text}\n            attribute netmask {text}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element ip_dst{\n            attribute address {text}\n            attribute netmask {text}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element l4_protocol{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element src_port{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           element dst_port{\n            attribute number {xsd:integer}\n            element filter_mode{\n                attribute behavior = {'discard'|'accept'}\n            }?\n           }\n     }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n            <ip_src address='131.114.54.0' netmask='255.255.252.0'>\n                <filter_mode behavior='discard'/>\n            </ip_src>\n \n            <ip_dst address='131.114.54.0' netmask='255.255.252.0'>\n                <filter_mode behavior='accept'/>\n             </ip_dst>\n \n             <l4_protocol number='6'>\n                <filter_mode behavior='accept'/>\n            </l4_protocol>\n \n            <src_port number='80'>\n                <filter_mode behavior='accept'/>\n            </src_port>\n \n      </params>\n    </paramsexample>\n", [], "", "Selects packets based on conditions specified over the 5-tuple", False), "Null": BlockInfo("Null", "direct", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Discards every message it receives.", "Discards every message it receives.", False), "SynFloodDetector": BlockInfo("SynFloodDetector", "direct", [GateInfo("input", "in_sketch", "SketchMsg", IntegerRange(0, 0)), GateInfo("output", "out_alert", "Alert", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element cusum {\n         attribute threshold {integer}\n         attribute offset {integer}\n         attribute mean_window {integer}\n       }\n       element bpf_filter {text}?\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <cusum threshold='50' offset='10' mean_window='20' />\n      </params>\n    </paramsexample>\n", [], "Detects TCP SYN Flooding from counters in sketches.  	   Sketches are received regularly with the number of TCP SYN packets  	   seen by destination IP since the last sketch was sent.      The CUSUM algorithm is used to detect abrupt changes in the numbers of      the sketch. Its parameters can be configured:  	    threshold is the indicator value over which an alarm will be raised       offset is the maximum rate of variation of the computed mean considered normal (between 0 and 1)       mean_window is the number of sketches on which the mean is computed      When a SYN flooding is detected, it is logged and a message is sent      through out_alert with the indexes of the cells in alarm. 	   This message may be used to identify the target of the attack.", "Detects TCP SYN Flooding from counters in sketches", False), "IPFIXExporter": BlockInfo("IPFIXExporter", "direct", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element domain {xsd:integer}?,\n        element export {\n            attribute transport {'udp'|'tcp'|'sctp'},\n            attribute host  {text},\n            attribute port  {xsd:integer}?\n            } |\n        element file {\n            attribute name {text}\n        }\n        element datatype {\n            attribute name {text}\n        }\n        element fastflush?\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <domain id='1'/>\n        <export host='ipfix-collector.example.net' port='4739' transport='tcp'/>\n        <datatype name='ipv4flow'/>\n        or\n        <file name='foo.ipfix'/>\n        <datatype name='ipv4flow'/>\n      </params>\n    </paramsexample>\n", [], "Receives a message and exports it via an IPFIX transport session or into   an IPFIX file. This block can handle any message class for which there   is a registered record type.    Note that this block can handle any message class for which an associated   datatype entry exists in the configuration. Messages sent to this block    for which no datatype entry is available are ignored but logged.", "Exports Blockmon messages via IPFIX", True), "SynFloodSourceCounter": BlockInfo("SynFloodSourceCounter", "direct", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0)), GateInfo("input", "in_alert", "Alert", IntegerRange(0, 0)), GateInfo("output", "out_alert", "Alert", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element sketch {\n         attribute width {integer}\n         attribute depth {integer}\n       }\n       element period {\n         attribute reset {integer}\n         attribute watch {integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n       <sketch width='1024' depth='8' />\n       <period  reset='30000000' watch='300000000'/>\n      </params>\n    </paramsexample>\n", [], "Counts the contribution in terms of SYN packets of each source using a sketch per target of attacks.", "Measures the contribution of each source of attack", False), "SyncTag": BlockInfo("SyncTag", "both", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0)), GateInfo("output", "out_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element tags\n        {\n            element tag {\n            attribute name {text}\n            }\n         }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <tag name = 'tag1'/>\n        <tag name = 'tag2'/>\n        </tags>\n        </params>\n    </paramsexample>\n", [], "Test block that waits for a message to have a set of tags set before forwarding it.    The block is configured with a set of tag to wait for: if all of them are written (the value is not read)    it forwards the message to the next block, otherwise it discards it.    If the same message is going through different parallel processing chains, is will reach the synchronization    block several times and eventually all of its tags will be written.", "Wait for a message to have a set of tags written", False), "ProtocolFilter": BlockInfo("ProtocolFilter", "direct", [GateInfo("input", "in_pkt", "Msg", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n           element protocol{\n            attribute type {xsd:integer}\n            }?\n           }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n            <!-- select IP packets -->\n            <protocol type='0800' />\n      </params>\n    </paramsexample>\n", [], "", "Selects packets based on the value of the ethernet type field", False)}
